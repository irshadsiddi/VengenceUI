{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "liquid-ocean",
  "type": "registry:ui",
  "dependencies": [],
  "files": [
    {
      "path": "components/ui/liquid-ocean.tsx",
      "content": "\"use client\";\n\nimport React, { useRef, useMemo, useEffect } from \"react\";\nimport { Canvas, useFrame, useThree } from \"@react-three/fiber\";\nimport { RectAreaLightUniformsLib } from \"three/examples/jsm/lights/RectAreaLightUniformsLib.js\";\nimport * as THREE from \"three\";\nimport { cn } from \"@/lib/utils\";\n\n// Initialize RectAreaLight uniforms\nif (typeof window !== \"undefined\") {\n    RectAreaLightUniformsLib.init();\n}\n\n// =============================================================================\n// DEFAULT THEME (Original \"Little Boxes\" Style - DO NOT CHANGE)\n// =============================================================================\nconst DEFAULT_THEME = {\n    background: 0x000000,\n    gridColor: 0x333333,\n    accentColor: 0xF00589, // The original pinkish color\n};\n\n// =============================================================================\n// OCEAN MESH COMPONENT\n// =============================================================================\ninterface OceanMeshProps {\n    geoSize: number;\n    geoFragments: number;\n    waveAmplitude: number;\n    waveSpeed: number;\n    accentColor: number;\n    showWireframe: boolean;\n    opacity: number;\n}\n\nfunction OceanMesh({\n    geoSize,\n    geoFragments,\n    waveAmplitude,\n    waveSpeed,\n    accentColor,\n    showWireframe,\n    opacity,\n}: OceanMeshProps) {\n    const meshRef = useRef<THREE.Mesh>(null);\n    const wireRef = useRef<THREE.Mesh>(null);\n\n    const { geometry, waves } = useMemo(() => {\n        const geo = new THREE.PlaneGeometry(geoSize, geoSize, geoFragments, geoFragments);\n        const positionAttribute = geo.getAttribute(\"position\");\n        const waveData: Array<{\n            x: number;\n            y: number;\n            z: number;\n            ang: number;\n            amp: number;\n            speed: number;\n        }> = [];\n\n        for (let i = 0; i < positionAttribute.count; i++) {\n            waveData.push({\n                x: positionAttribute.getX(i),\n                y: positionAttribute.getY(i),\n                z: positionAttribute.getZ(i),\n                ang: Math.PI * 2,\n                amp: Math.random() * waveAmplitude,\n                speed: 0.03 + Math.random() * waveSpeed,\n            });\n        }\n\n        return { geometry: geo, waves: waveData };\n    }, [geoSize, geoFragments, waveAmplitude, waveSpeed]);\n\n    useFrame(() => {\n        if (!meshRef.current) return;\n\n        const positionAttribute = meshRef.current.geometry.getAttribute(\"position\");\n\n        for (let i = 0; i < positionAttribute.count; i++) {\n            const wave = waves[i];\n            positionAttribute.setX(i, wave.x + Math.cos(wave.ang) * wave.amp);\n            positionAttribute.setY(i, wave.y + Math.sin(wave.ang / 2) * wave.amp);\n            positionAttribute.setZ(i, wave.z + Math.cos(wave.ang / 3) * wave.amp);\n            wave.ang += wave.speed;\n        }\n\n        positionAttribute.needsUpdate = true;\n    });\n\n    const wireframeMaterial = useMemo(\n        () =>\n            new THREE.MeshPhysicalMaterial({\n                color: accentColor,\n                wireframe: true,\n                transparent: false,\n                opacity: 1,\n            }),\n        [accentColor]\n    );\n\n    const surfaceMaterial = useMemo(\n        () =>\n            new THREE.MeshPhysicalMaterial({\n                color: accentColor,\n                transparent: true,\n                opacity: opacity,\n                wireframe: false,\n            }),\n        [accentColor, opacity]\n    );\n\n    return (\n        <group rotation={[-90 * Math.PI / 180, 0, 0]}>\n            <mesh ref={meshRef} geometry={geometry} material={surfaceMaterial} receiveShadow />\n            {showWireframe && (\n                <mesh ref={wireRef} geometry={geometry} material={wireframeMaterial} />\n            )}\n        </group>\n    );\n}\n\n// =============================================================================\n// BOAT / FLOATING BOXES COMPONENT\n// =============================================================================\ninterface BoatData {\n    position: [number, number, number];\n    scale: [number, number, number];\n    rotationY: number;\n    vel: number;\n    amp: number;\n    pos: number;\n}\n\nfunction Boat({ data, color }: { data: BoatData; color: number }) {\n    const meshRef = useRef<THREE.Mesh>(null);\n\n    useFrame(({ clock }) => {\n        if (!meshRef.current) return;\n        const time = clock.getElapsedTime() * 3;\n\n        meshRef.current.rotation.z = (Math.sin(time / data.vel) * data.amp * Math.PI) / 180;\n        meshRef.current.rotation.x = (Math.cos(time) * data.vel * Math.PI) / 180;\n        meshRef.current.position.y = Math.sin(time / data.vel) * data.pos;\n    });\n\n    return (\n        <mesh\n            ref={meshRef}\n            position={data.position}\n            rotation={[0, data.rotationY, 0]}\n            scale={data.scale}\n            castShadow\n        >\n            <boxGeometry args={[1, 1, 1]} />\n            <meshStandardMaterial color={color} />\n        </mesh>\n    );\n}\n\nfunction BoatGroup({ count, spreadRange, color }: { count: number; spreadRange: number; color: number }) {\n    const boats = useMemo(() => {\n        const items: BoatData[] = [];\n        for (let i = 0; i < count; i++) {\n            const x = -Math.random() * spreadRange + Math.random() * spreadRange;\n            const z = -Math.random() * spreadRange + Math.random() * spreadRange;\n            const sX = Math.random();\n            const sY = 0.5 + Math.random() * 2;\n\n            items.push({\n                position: [x, 0, z],\n                scale: [sX, sY, sX],\n                rotationY: (Math.random() * 360 * Math.PI) / 180,\n                vel: 1 + Math.random() * 4,\n                amp: 1 + Math.random() * 6,\n                pos: Math.random() * 0.2,\n            });\n        }\n        return items;\n    }, [count, spreadRange]);\n\n    return (\n        <group>\n            {boats.map((boat, i) => (\n                <Boat key={i} data={boat} color={color} />\n            ))}\n        </group>\n    );\n}\n\n// =============================================================================\n// SCENE CONTENT\n// =============================================================================\ninterface SceneContentProps {\n    backgroundColor: number;\n    gridColor: number;\n    accentColor: number;\n    rotationSpeed: number;\n    showGrid: boolean;\n    showBoats: boolean;\n    boatCount: number;\n    boatSpread: number;\n    oceanSize: number;\n    oceanFragments: number;\n    waveAmplitude: number;\n    waveSpeed: number;\n    showWireframe: boolean;\n    oceanOpacity: number;\n}\n\nfunction SceneContent({\n    backgroundColor,\n    gridColor,\n    accentColor,\n    rotationSpeed,\n    showGrid,\n    showBoats,\n    boatCount,\n    boatSpread,\n    oceanSize,\n    oceanFragments,\n    waveAmplitude,\n    waveSpeed,\n    showWireframe,\n    oceanOpacity,\n}: SceneContentProps) {\n    const { scene, camera } = useThree();\n    const rectLightRef = useRef<THREE.RectAreaLight>(null);\n    const groupRef = useRef<THREE.Group>(null);\n\n    useEffect(() => {\n        scene.fog = new THREE.Fog(backgroundColor, 5, 20);\n        scene.background = new THREE.Color(backgroundColor);\n    }, [scene, backgroundColor]);\n\n    useFrame(() => {\n        camera.lookAt(0, 0, 0);\n        if (rectLightRef.current) {\n            rectLightRef.current.lookAt(0, 0, 0);\n        }\n        if (groupRef.current) {\n            groupRef.current.rotation.y += rotationSpeed;\n        }\n    });\n\n    return (\n        <>\n            {/* Lighting - Original setup */}\n            <hemisphereLight args={[0xFFD3D3, accentColor, 2]} />\n            <pointLight args={[accentColor, 1]} position={[-5, -20, -20]} />\n            <rectAreaLight\n                ref={rectLightRef}\n                args={[accentColor, 20, 3, 3]}\n                position={[2, 2, -20]}\n            />\n            <pointLight args={[accentColor, 0.1]} position={[0, 2, -2]} />\n\n            {/* Rotating Group */}\n            <group ref={groupRef}>\n                {showGrid && <gridHelper args={[20, 20]} position={[0, -1, 0]} />}\n                {showBoats && <BoatGroup count={boatCount} spreadRange={boatSpread} color={accentColor} />}\n                <OceanMesh\n                    geoSize={oceanSize}\n                    geoFragments={oceanFragments}\n                    waveAmplitude={waveAmplitude}\n                    waveSpeed={waveSpeed}\n                    accentColor={accentColor}\n                    showWireframe={showWireframe}\n                    opacity={oceanOpacity}\n                />\n            </group>\n        </>\n    );\n}\n\n// =============================================================================\n// MAIN COMPONENT - Props for reusability, defaults match original exactly\n// =============================================================================\nexport interface LiquidOceanProps {\n    /** Additional CSS classes */\n    className?: string;\n    /** Background color as hex number (default: 0x000000 - black) */\n    backgroundColor?: number;\n    /** Grid line color as hex number (default: 0x333333) */\n    gridColor?: number;\n    /** Accent color for ocean, boats, lights as hex number (default: 0xF00589 - pink) */\n    accentColor?: number;\n    /** Camera field of view (default: 20) */\n    fov?: number;\n    /** Scene rotation speed per frame (default: 0.001) */\n    rotationSpeed?: number;\n    /** Show grid helper (default: true) */\n    showGrid?: boolean;\n    /** Show floating boxes/boats (default: true) */\n    showBoats?: boolean;\n    /** Number of floating boxes (default: 5) */\n    boatCount?: number;\n    /** Spread range for floating boxes (default: 5) */\n    boatSpread?: number;\n    /** Ocean plane size (default: 25) */\n    oceanSize?: number;\n    /** Ocean geometry fragments/subdivisions (default: 25) */\n    oceanFragments?: number;\n    /** Maximum wave amplitude (default: 0.2) */\n    waveAmplitude?: number;\n    /** Wave animation speed multiplier (default: 0.05) */\n    waveSpeed?: number;\n    /** Show wireframe overlay on ocean (default: true) */\n    showWireframe?: boolean;\n    /** Ocean surface opacity (default: 0.85) */\n    oceanOpacity?: number;\n    /** Overlay content (e.g., title text) */\n    children?: React.ReactNode;\n}\n\nexport function LiquidOcean({\n    className,\n    // Original colors - DO NOT CHANGE DEFAULTS\n    backgroundColor = DEFAULT_THEME.background,\n    gridColor = DEFAULT_THEME.gridColor,\n    accentColor = DEFAULT_THEME.accentColor,\n    // Original settings - DO NOT CHANGE DEFAULTS\n    fov = 20,\n    rotationSpeed = 0.001,\n    showGrid = true,\n    showBoats = true,\n    boatCount = 5,\n    boatSpread = 5,\n    oceanSize = 25,\n    oceanFragments = 25,\n    waveAmplitude = 0.2,\n    waveSpeed = 0.05,\n    showWireframe = true,\n    oceanOpacity = 0.85,\n    children,\n}: LiquidOceanProps) {\n    return (\n        <div className={cn(\"relative w-full h-full min-h-[400px] overflow-hidden bg-black cursor-crosshair\", className)}>\n            <Canvas\n                shadows\n                camera={{ position: [0, 2, 10], fov }}\n                gl={{ antialias: true, alpha: false }}\n                style={{ position: \"absolute\", inset: 0 }}\n            >\n                <SceneContent\n                    backgroundColor={backgroundColor}\n                    gridColor={gridColor}\n                    accentColor={accentColor}\n                    rotationSpeed={rotationSpeed}\n                    showGrid={showGrid}\n                    showBoats={showBoats}\n                    boatCount={boatCount}\n                    boatSpread={boatSpread}\n                    oceanSize={oceanSize}\n                    oceanFragments={oceanFragments}\n                    waveAmplitude={waveAmplitude}\n                    waveSpeed={waveSpeed}\n                    showWireframe={showWireframe}\n                    oceanOpacity={oceanOpacity}\n                />\n            </Canvas>\n\n            {/* Overlay Content */}\n            {children && (\n                <div className=\"absolute inset-0 pointer-events-none select-none\">\n                    {children}\n                </div>\n            )}\n        </div>\n    );\n}\n\nexport default LiquidOcean;\n",
      "type": "registry:ui",
      "target": "components/ui/liquid-ocean.tsx"
    }
  ]
}