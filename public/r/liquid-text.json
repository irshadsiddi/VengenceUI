{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "liquid-text",
  "type": "registry:ui",
  "dependencies": [],
  "files": [
    {
      "path": "components/ui/liquid-text.tsx",
      "content": "\"use client\";\n\nimport { useEffect, useRef } from \"react\";\nimport * as THREE from \"three\";\nimport { cn } from \"@/lib/utils\";\n\ninterface LiquidTextProps {\n    /** Text to display */\n    text?: string;\n    /** Font size in pixels */\n    fontSize?: number;\n    /** Font family */\n    font?: string;\n    /** Fixed text color (overrides theme colors) */\n    color?: string;\n    /** Text color in light mode */\n    lightColor?: string;\n    /** Text color in dark mode */\n    darkColor?: string;\n    /** Additional CSS classes */\n    className?: string;\n}\n\nconst createTextTexture = (text: string, size: number, font: string, color: string): THREE.Texture => {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = 2048;\n    canvas.height = 2048;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return new THREE.CanvasTexture(canvas);\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.font = `bold ${size}px ${font}`;\n    ctx.fillStyle = color;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(text, canvas.width / 2, canvas.height / 2);\n\n    const texture = new THREE.CanvasTexture(canvas);\n    texture.needsUpdate = true;\n    return texture;\n};\n\nconst vertexShader = `\n    varying vec2 vUv;\n    uniform vec3 uDisplacement;\n\n    float easeInOutCubic(float x) {\n        return x < 0.5 ? 4.0 * x * x * x : 1.0 - pow(-2.0 * x + 2.0, 3.0) / 2.0;\n    }\n\n    float map(float value, float min1, float max1, float min2, float max2) {\n        return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n    }\n\n    void main() {\n        vUv = uv;\n        vec3 displaced = position;\n        vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n        float dist = length(uDisplacement - worldPosition.rgb);\n        float minDistance = 3.0;\n\n        if (dist < minDistance) {\n            float mapped = map(dist, 0.0, minDistance, 1.0, 0.0);\n            displaced.z += easeInOutCubic(mapped);\n        }\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced, 1.0);\n    }\n`;\n\nconst fragmentShader = `\n    varying vec2 vUv;\n    uniform sampler2D uTexture;\n\n    void main() {\n        gl_FragColor = texture2D(uTexture, vUv);\n    }\n`;\n\nexport function LiquidText({\n    text = \"Liquid Text\",\n    fontSize = 200,\n    font = \"Inter, sans-serif\",\n    color,\n    lightColor = \"#000000\",\n    darkColor = \"#ffffff\",\n    className,\n}: LiquidTextProps) {\n    const containerRef = useRef<HTMLDivElement>(null);\n\n    useEffect(() => {\n        const container = containerRef.current;\n        if (!container) return;\n\n        const rect = container.getBoundingClientRect();\n        const width = rect.width || 1;\n        const height = rect.height || 1;\n        if (height === 0) return;\n\n        const scene = new THREE.Scene();\n        scene.background = null;\n\n        const cameraDistance = 8;\n        const aspect = width / height;\n        const camera = new THREE.OrthographicCamera(\n            -cameraDistance * aspect, cameraDistance * aspect,\n            cameraDistance, -cameraDistance, 0.01, 1000\n        );\n        camera.position.set(0, -10, 5);\n        camera.lookAt(0, 0, 0);\n\n        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n        renderer.setClearColor(0x000000, 0);\n        renderer.setPixelRatio(window.devicePixelRatio);\n        renderer.setSize(width, height, false);\n        renderer.domElement.style.width = \"100%\";\n        renderer.domElement.style.height = \"100%\";\n        container.appendChild(renderer.domElement);\n\n        const geometry = new THREE.PlaneGeometry(15, 15, 100, 100);\n        const getActiveColor = () => color || (document.documentElement.classList.contains(\"dark\") ? darkColor : lightColor);\n\n        let currentColor = getActiveColor();\n        let textTexture = createTextTexture(text, fontSize, font, currentColor);\n\n        const shaderMaterial = new THREE.ShaderMaterial({\n            uniforms: {\n                uTexture: { value: textTexture },\n                uDisplacement: { value: new THREE.Vector3(0, 0, 0) },\n            },\n            vertexShader,\n            fragmentShader,\n            transparent: true,\n            depthWrite: false,\n            side: THREE.DoubleSide,\n        });\n\n        const plane = new THREE.Mesh(geometry, shaderMaterial);\n        plane.rotation.z = Math.PI / 4;\n        scene.add(plane);\n\n        const hitPlane = new THREE.Mesh(\n            new THREE.PlaneGeometry(500, 500),\n            new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 })\n        );\n        scene.add(hitPlane);\n\n        const raycaster = new THREE.Raycaster();\n        const pointer = new THREE.Vector2();\n\n        const onPointerMove = (e: PointerEvent) => {\n            const bounds = container.getBoundingClientRect();\n            pointer.x = ((e.clientX - bounds.left) / bounds.width) * 2 - 1;\n            pointer.y = -((e.clientY - bounds.top) / bounds.height) * 2 + 1;\n            raycaster.setFromCamera(pointer, camera);\n            const [hit] = raycaster.intersectObject(hitPlane);\n            if (hit) (shaderMaterial.uniforms.uDisplacement.value as THREE.Vector3).copy(hit.point);\n        };\n\n        container.addEventListener(\"pointermove\", onPointerMove);\n\n        const handleResize = () => {\n            const r = container.getBoundingClientRect();\n            if (r.height === 0) return;\n            const a = r.width / r.height;\n            camera.left = -cameraDistance * a;\n            camera.right = cameraDistance * a;\n            camera.updateProjectionMatrix();\n            renderer.setSize(r.width, r.height, false);\n        };\n\n        window.addEventListener(\"resize\", handleResize);\n\n        let animationId = 0;\n        const render = () => {\n            animationId = requestAnimationFrame(render);\n            renderer.render(scene, camera);\n        };\n        render();\n\n        const observer = new MutationObserver(() => {\n            const next = getActiveColor();\n            if (next !== currentColor) {\n                const tex = createTextTexture(text, fontSize, font, next);\n                shaderMaterial.uniforms.uTexture.value = tex;\n                textTexture.dispose();\n                textTexture = tex;\n                currentColor = next;\n            }\n        });\n        if (!color) observer.observe(document.documentElement, { attributes: true, attributeFilter: [\"class\"] });\n\n        return () => {\n            window.removeEventListener(\"resize\", handleResize);\n            container.removeEventListener(\"pointermove\", onPointerMove);\n            cancelAnimationFrame(animationId);\n            observer.disconnect();\n            if (renderer.domElement.parentNode === container) container.removeChild(renderer.domElement);\n            renderer.dispose();\n            textTexture.dispose();\n            geometry.dispose();\n            shaderMaterial.dispose();\n        };\n    }, [text, fontSize, font, color, lightColor, darkColor]);\n\n    return <div ref={containerRef} className={cn(\"relative w-full h-[600px]\", className)} />;\n}\n\nexport default LiquidText;\n",
      "type": "registry:ui",
      "target": "components/ui/liquid-text.tsx"
    }
  ]
}