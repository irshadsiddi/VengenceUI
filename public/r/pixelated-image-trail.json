{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pixelated-image-trail",
  "type": "registry:ui",
  "dependencies": [],
  "files": [
    {
      "path": "components/ui/pixelated-image-trail.tsx",
      "content": "\"use client\";\n\nimport { useEffect, useRef, useState } from \"react\";\nimport { createPortal } from \"react-dom\";\nimport { cn } from \"@/lib/utils\";\n\n/**\n * Configuration options for the pixelated image trail effect\n */\ninterface TrailConfig {\n    /** Duration (ms) before an image starts fading out */\n    imageLifespan: number;\n    /** Duration (ms) of the reveal animation */\n    inDuration: number;\n    /** Duration (ms) of the hide animation */\n    outDuration: number;\n    /** Stagger delay (ms) for slices during reveal */\n    staggerIn: number;\n    /** Stagger delay (ms) for slices during hide */\n    staggerOut: number;\n    /** Duration (ms) of the slide animation */\n    slideDuration: number;\n    /** CSS easing function for slide animation */\n    slideEasing: string;\n    /** CSS easing function for mask animations */\n    easing: string;\n}\n\n/**\n * Props for the PixelatedImageTrail component\n */\nexport interface PixelatedImageTrailProps {\n    /** Additional CSS classes for the trail container */\n    className?: string;\n    /** Array of image URLs to cycle through */\n    images?: string[];\n    /** Override partial configuration options */\n    config?: Partial<TrailConfig>;\n    /** Number of horizontal slices (affects pixelation effect) */\n    slices?: number;\n    /** Distance threshold for spawning new trail images */\n    spawnThreshold?: number;\n    /** Interpolation factor for mouse smoothing (0-1) */\n    smoothing?: number;\n}\n\n/**\n * PixelatedImageTrail - A stunning hover effect that creates a trail of pixelated images\n * following the cursor. Images reveal with a slice-based animation creating a \n * premium, dynamic visual effect.\n * \n * @example\n * ```tsx\n * <PixelatedImageTrail\n *   images={['/image1.jpg', '/image2.jpg', '/image3.jpg']}\n *   config={{ imageLifespan: 1200, staggerIn: 40 }}\n * />\n * ```\n */\nexport function PixelatedImageTrail({\n    className,\n    images = [],\n    config: configOverride = {},\n    slices = 4,\n    spawnThreshold = 100,\n    smoothing = 0.1,\n}: PixelatedImageTrailProps) {\n    const [mounted, setMounted] = useState(false);\n    const trailContainerRef = useRef<HTMLDivElement>(null);\n    const currentImageIndexRef = useRef(0);\n    const mousePosRef = useRef({ x: 0, y: 0 });\n    const lastMousePosRef = useRef({ x: 0, y: 0 });\n    const interpolatedMousePosRef = useRef({ x: 0, y: 0 });\n    const animationFrameRef = useRef<number | null>(null);\n    const validImagesRef = useRef<string[]>([]);\n\n    const trailImageCount = 3;\n    const finalImages = images.length > 0 ? images : Array.from(\n        { length: trailImageCount },\n        (_, i) => `/trail-images/image${i + 1}.jpg`\n    );\n\n    // Preload images and only use them once loaded\n    useEffect(() => {\n        validImagesRef.current = [];\n        finalImages.forEach(src => {\n            const img = new Image();\n            img.src = src;\n            img.onload = () => {\n                validImagesRef.current.push(src);\n            };\n        });\n    }, [JSON.stringify(finalImages)]);\n\n    useEffect(() => {\n        setMounted(true);\n    }, []);\n\n    useEffect(() => {\n        if (!mounted) return;\n\n        // Default configuration - Codrops-optimized timing\n        const defaultConfig: TrailConfig = {\n            imageLifespan: 400,\n            inDuration: 150,\n            outDuration: 300,\n            staggerIn: 6,\n            staggerOut: 4,\n            slideDuration: 900,\n            slideEasing: \"cubic-bezier(0.16, 1, 0.3, 1)\", // Expo.easeOut\n            easing: \"cubic-bezier(0.16, 1, 0.3, 1)\",\n        };\n\n        const config = { ...defaultConfig, ...configOverride };\n\n        const trailContainer = trailContainerRef.current;\n        if (!trailContainer) return;\n\n        // Math utilities for smooth interpolation\n        const MathUtils = {\n            lerp: (a: number, b: number, n: number) => (1 - n) * a + n * b,\n            distance: (x1: number, y1: number, x2: number, y2: number) =>\n                Math.hypot(x2 - x1, y2 - y1),\n        };\n\n        const getMouseDistance = () =>\n            MathUtils.distance(\n                interpolatedMousePosRef.current.x,\n                interpolatedMousePosRef.current.y,\n                lastMousePosRef.current.x,\n                lastMousePosRef.current.y\n            );\n\n        /**\n         * Creates a trail image element with pixelated slice animation\n         */\n        const createTrailImage = () => {\n            // Skip if no images are loaded yet to prevent glitches\n            if (validImagesRef.current.length === 0) return;\n\n            const imgContainer = document.createElement(\"div\");\n            imgContainer.classList.add(\"pixelated-trail-img\");\n\n            // Use only valid loaded images\n            const imgSrc = validImagesRef.current[currentImageIndexRef.current % validImagesRef.current.length];\n            currentImageIndexRef.current = (currentImageIndexRef.current + 1) % validImagesRef.current.length;\n\n            const rect = trailContainer.getBoundingClientRect();\n            // ... rest of function ...\n            const startX = interpolatedMousePosRef.current.x - rect.left - 87.5;\n            const startY = interpolatedMousePosRef.current.y - rect.top - 87.5;\n\n            const dx = mousePosRef.current.x - interpolatedMousePosRef.current.x;\n            const dy = mousePosRef.current.y - interpolatedMousePosRef.current.y;\n\n            const targetX = startX + dx * 0.5;\n            const targetY = startY + dy * 0.5;\n\n            // Codrops doesn't use specific rotation, just proper placement\n            // We keep it simple: translate only, no rotation or scale-in\n            imgContainer.style.transform = `translate3d(0, 0, 0)`;\n\n            imgContainer.style.left = `${startX}px`;\n            imgContainer.style.top = `${startY}px`;\n            imgContainer.style.transition = `left ${config.slideDuration}ms ${config.slideEasing}, top ${config.slideDuration}ms ${config.slideEasing}`;\n\n            const maskLayers: HTMLDivElement[] = [];\n\n            // Create sliced layers for pixelation effect\n            for (let i = 0; i < slices; i++) {\n                const layer = document.createElement(\"div\");\n                layer.classList.add(\"pixelated-mask-layer\");\n\n                const imageLayer = document.createElement(\"div\");\n                imageLayer.classList.add(\"pixelated-image-layer\");\n                imageLayer.style.backgroundImage = `url(${imgSrc})`;\n\n                const sliceSize = 100 / slices;\n                const startClipY = i * sliceSize;\n                const endClipY = (i + 1) * sliceSize;\n\n                // Initial collapsed clip-path (hidden)\n                layer.style.clipPath = `polygon(50% ${startClipY}%, 50% ${startClipY}%, 50% ${endClipY}%, 50% ${endClipY}%)`;\n                layer.style.transition = `clip-path ${config.inDuration}ms ${config.easing}`;\n                layer.style.transform = \"translateZ(0)\";\n                layer.style.backfaceVisibility = \"hidden\";\n\n                layer.appendChild(imageLayer);\n                imgContainer.appendChild(layer);\n                maskLayers.push(layer);\n            }\n\n            trailContainer.appendChild(imgContainer);\n\n            // Animate in with staggered slice reveal + scale pop\n            requestAnimationFrame(() => {\n                imgContainer.style.left = `${targetX}px`;\n                imgContainer.style.top = `${targetY}px`;\n                // No rotation or scale change on enter - just position\n                imgContainer.style.transform = `translate3d(0, 0, 0)`;\n\n                maskLayers.forEach((layer, i) => {\n                    const sliceSize = 100 / slices;\n                    const startClipY = i * sliceSize;\n                    const endClipY = (i + 1) * sliceSize;\n\n                    // Ripple stagger from center outwards\n                    const distanceFromMiddle = Math.abs(i - (slices - 1) / 2);\n                    const delay = distanceFromMiddle * config.staggerIn;\n\n                    setTimeout(() => {\n                        layer.style.clipPath = `polygon(0% ${startClipY}%, 100% ${startClipY}%, 100% ${endClipY}%, 0% ${endClipY}%)`;\n                    }, delay);\n                });\n            });\n\n            // Animate out - Codrops style fade + scale down\n            setTimeout(() => {\n                // Use CSS class for reliable exit transition\n                imgContainer.classList.add(\"animate-out\");\n\n                // Remove from DOM after fade completes\n                setTimeout(() => {\n                    if (imgContainer.parentElement === trailContainer) {\n                        trailContainer.removeChild(imgContainer);\n                    }\n                }, config.outDuration);\n            }, config.imageLifespan);\n        };\n\n        const handleMouseMove = (e: MouseEvent) => {\n            mousePosRef.current = { x: e.clientX, y: e.clientY };\n        };\n\n        /**\n         * Animation loop with smooth mouse interpolation\n         */\n        const render = () => {\n            interpolatedMousePosRef.current.x = MathUtils.lerp(\n                interpolatedMousePosRef.current.x,\n                mousePosRef.current.x,\n                smoothing\n            );\n            interpolatedMousePosRef.current.y = MathUtils.lerp(\n                interpolatedMousePosRef.current.y,\n                mousePosRef.current.y,\n                smoothing\n            );\n\n            if (getMouseDistance() > spawnThreshold) {\n                lastMousePosRef.current = { ...interpolatedMousePosRef.current };\n                createTrailImage();\n            }\n\n            animationFrameRef.current = requestAnimationFrame(render);\n        };\n\n        window.addEventListener(\"mousemove\", handleMouseMove);\n        animationFrameRef.current = requestAnimationFrame(render);\n\n        // Initialize mouse position on first move\n        const initMouse = (e: MouseEvent) => {\n            mousePosRef.current = { x: e.clientX, y: e.clientY };\n            interpolatedMousePosRef.current = { x: e.clientX, y: e.clientY };\n            lastMousePosRef.current = { x: e.clientX, y: e.clientY };\n            window.removeEventListener(\"mousemove\", initMouse);\n        }\n        window.addEventListener(\"mousemove\", initMouse, { once: true });\n\n\n        return () => {\n            window.removeEventListener(\"mousemove\", handleMouseMove);\n            if (animationFrameRef.current) cancelAnimationFrame(animationFrameRef.current);\n        };\n    }, [mounted, configOverride, slices, spawnThreshold, smoothing, JSON.stringify(images)]);\n\n    if (!mounted) return null;\n\n    return createPortal(\n        <div className={cn(\"pixelated-trail-container\", className)} ref={trailContainerRef}></div>,\n        document.body\n    );\n}\n\nexport default PixelatedImageTrail;\n",
      "type": "registry:ui",
      "target": "components/ui/pixelated-image-trail.tsx"
    }
  ]
}